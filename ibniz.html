<html>
<head>
</head>
<body>
<canvas id="ibniz" width="256" height="256">
Why u no canvas
</canvas><br>
<form>
	<input type="text" id="code" style="width: 256px"><br>
<input type="checkbox" id="pause">Pause <input type="button" onclick="loadFileURL()" value="Load...">
</form>
<div id="fps"><b>FPS:</b> [implementing, give me a second]</div>
<b>DEBUG:</b><br>
<script type="text/javascript">
/* This program is free software. It comes without any warranty, to
 * the extent permitted by applicable law. You can redistribute it
 * and/or modify it under the terms of the Do What The Fuck You Want
 * To Public License, Version 2, as published by Sam Hocevar. See
 * http://sam.zoy.org/wtfpl/COPYING for more details. */

function Stack (len)
{
	//var buffer = new ArrayBuffer(4096);
	//this.stack = new Int32Array(buffer);
	this.stack = new Array(len);
	this.pos = -1;
	this.push = function(v){
		if(this.pos==4095) return -1;
		this.pos++;
		this.stack[this.pos]=v|0;
		return 0;
	}
	this.push2 = function(v){
		if(this.pos>=4094) return -1;
		this.pos+=2;
		this.stack[this.pos-1]=v|0;
		this.stack[this.pos]=v|0;
		return 0;
	}
	this.pop = function(){
		if(this.pos==-1) return 0;
		this.pos--;
		return this.stack[this.pos+1];
	}
	this.get = function(addr) {
		return this.stack[addr&4095];
	}
	this.gettop = function(addr) {
		return this.stack[(this.pos+addr)&4095];
	}
	this.put = function(addr,v) {
		this.stack[addr&4095]=v|0;
	}
	this.puttop = function(addr,v) {
		this.stack[(this.pos+addr)&4095]=v|0;
	}
	this.clear = function(){
		this.pos=-1;
	}
	this.size = function(){
		return this.pos+1;
	}
	this.exchange = function(){
		if(this.pos<1) return -1;
		var temp = this.stack[this.pos];
		this.stack[this.pos]=this.stack[this.pos-1];
		this.stack[this.pos-1]=temp;
		return 0;
	}
	this.trirot = function(){
		if(this.pos<2) return -1;
		var temp = this.stack[this.pos];
		this.stack[this.pos]=this.stack[this.pos-2];
		this.stack[this.pos-2]=this.stack[this.pos-1];
		this.stack[this.pos-1]=temp;
		return 0;
	}
	this.dup = function(){
		return this.push(this.stack[this.pos]);
	}
	this.debug = function(){
		document.write("Testing Stack...<br>");
		this.push(32);
		document.write("[BASIC] 1/6: " + this.pop() + " == 32<br>");
		this.push(64);
		this.push(25);
		this.exchange();
		document.write("[EXCH] 2/6: " + this.pop() + " == 64<br>");
		document.write("[EXCH] 3/6: " + this.pop() + " == 25<br>");
		this.push(33);
		this.push(22);
		this.push(11);
		this.trirot();
		document.write("[TRIROT] 4/6: " + this.pop() + " == 33<br>");
		this.pop();
		this.pop();
		document.write("[POP] 5/6: " + this.pop() + " == 0<br>");
		document.write("[EXC2] 6/6: " + this.exchange() + " == -1<br>");
	}
	this.print = function(){
		var str = "";
		for(var i=0;i<=this.pos;i++)
		{
			str = str + this.stack[i] + ",";
		}
		return str;
	}
}
function Memory ()
{
	this.mem = new Array(1024*1024);
	// 0xC8000-0xCFFFF - return stacks
	// 0xD0000-0xFFFFF - stacks
	this.get = function(addr){
		if(addr<0xC8000)
			return this.mem[addr&1048575];
		else if(addr>=0xE0000)
			return this.stack.get(addr&0x1FFFF);
		else if(addr>=0xD0000)
			return this.stack.get(addr&0xFFFF);
		else
			return this.rstack.get(addr&0x3FFF);
	}
	this.put = function(addr,val){
		if(addr<0xC8000)
			this.mem[addr&1048575] = val;
		else if(addr>=0xE0000)
			this.stack.put(addr&0x1FFFF,val);
		else if(addr>=0xD0000)
			this.stack.put(addr&0xFFFF,val);
		else
			this.rstack.put(addr&0x3FFF,val);
	}
}
function ALU ()
{
	this.add = function(a,b){
		return a+b;
	}
	this.sub = function(a,b){
		return b-a;
	}
	this.mul = function(a,b){
		return (a*b)/65536;
	}
	this.div = function(a,b){
		return (b*65536)/a;
	}
	this.mod = function(a,b){
		return b%a;
	}
	this.sqrt = function(a){
		if(a<0) return 0;
		else return Math.sqrt(a/65536.0)*65536.0; 
	}
	this.and = function(a,b){
		return a&b;
	}
	this.or = function(a,b){
		return a|b;
	}
	this.xor = function(a,b){
		return a^b;
	}
	this.not = function(a){
		return ~a;
	}
	this.sin = function(a){
        return Math.sin(a*(2*Math.PI/65536))*65536;
	}
	this.atan2 = function(a,b){
		return Math.atan2(a,b)*(65536/(2*Math.PI));
	}
	this.isneg = function(a){
		return a<0?a:0;
	}
	this.ispos = function(a){
		return a>0?a:0;
	}
	this.iszero = function(a){
		return a==0?1:0;
	}
	this.shl = function(a,b){
		var steps = (a>>16)&63;
		if(steps<32) return b<<steps;
		else return b>>(steps-32);
	}
	this.rol = function(a,b){
		var steps = (a>>16)&31;
		return ((b<<steps)|(b>>>(32-steps)));
	}
	this.ror = function(a,b){
		var steps = (a>>16)&31;
		return ((b>>>steps)|(b<<(32-steps)));
	}
	this.a2f = function(a){
		return (a/65536);
	}
	this.f2a = function(a){
		return Math.round(a*65536);
	}
}
function Parser()
{
	this.code = "";
	this.parsedCode = new Array();
	this.ip = 0;
	this.t = 0;
	this.x = 0;
	this.y = 0;
	this.xy = 0;
	this.mode = 0;
	this.terminate = 0;
	this.stackmode = 0;
	this.videoout = 0;
	this.audioout = 0;
	this.stack = new Stack(0x20000);
	this.rstack = new Stack(0x4000);
	this.alu = new ALU();
	this.mem = new Memory();
	this.mem.stack = this.stack;
	this.mem.rstack = this.rstack;
	this.load = function(c)
	{
		this.code=c;
		this.parsedCode = new Array();
		this.compile();
		this.configureStackmode();
	}
	this.rol16 = function(b){
		return ((b<<16)|(b>>>16));
	}
	this.pushmedia = function()
	{
		if(this.mode==0)
			switch(this.stackmode)
			{
				case 0:
					this.stack.push(this.alu.f2a(Math.floor(this.t)));
					this.stack.push(this.alu.f2a((this.y/128)-1));
					this.stack.push(this.alu.f2a((this.x/128)-1));
					break;
				case 1:
					this.stack.push(this.alu.f2a(Math.floor(this.t)) | ((y&255)<<8) | (x&255));
					break;
			}
		else this.stack.push(this.alu.f2a(this.t));
	}
	this.run = function()
	{
		// reset the machine
		this.mode = 0;
		this.terminate = 0;
		this.stack.clear();
		this.ip = 0;
		this.xy = (y<<8)|x;
		// push media context
		this.pushmedia();
		// loop
		while(this.terminate!=1)
		{
			this.execOne();
			this.ip++;
		}
		if(this.mode==0)
		{
			// run audio, too
			this.videoout = this.stack.pop();
			// No audio code yet!
			/*
			this.mode=1;
			this.terminate = 0;
			this.stack.clear();
			this.ip = 0;
			this.pushmedia();
			while(this.terminate!=1)
			{
				this.execOne();
				this.ip++;
			}
			*/
		}
		this.audioout = this.stack.pop();
	}
	this.isLimm = function(ci)
	{
		// is 0-9? A-F? .?
		return ((ci>=48 && ci<=57) || (ci>=65 && ci<=70) || (ci==46));
	}
	this.isImmop = function(ci)
	{
		return ((ci>=112 && ci<=115)||ci==43||ci==45||ci==42||ci==47||ci==37||ci==38||ci==124||ci==94||ci==108||ci==126||ci==97||ci==100);
	}
	this.isOpcode = function(ci)
	{
		return (this.isImmop(ci) || this.isLimm(ci) || ci==77||(ci>=118&&ci<=120)||ci==40||ci==41||ci==63||ci==33||ci==64||ci==58||ci==59||ci==80||ci==82||ci==84||ci==105||ci==106||ci==74||ci==91||ci==93||ci==88||ci==76||ci==123||ci==125||ci==86);
	}
	this.compile = function()
	{
		var i = 0;
		var j = 0;
		while(i<this.code.length)
		{
			var a = this.code[i].charCodeAt(0);
			if(this.isLimm(a))
			{
				// Loadimm!
				var imm1 = 0; // number
				var imm2 = 0; // fraction
				var mode = 0; // number/fraction time?
				while(this.isLimm(a) && i<this.code.length)
				{
					if(a==46) mode=1; // dot, time to switch modes!
					else {
						if(mode==0)
						{
							if(a>=48 && a<=57) imm1=(imm1<<4)|(a-48); // number, 0-9
							else imm1=(imm1<<4)|(a-55); // fraction, A-F
						}
						else
						{
							if(a>=48 && a<=57) imm2=(imm2>>4)|((a-48)<<12); // fraction, 0-9
							else imm2=(imm2>>4)|((a-55)<<12); // fraction, A-F
						}
					}
					i++; // increment IP
					if(i<this.code.length) a = this.code[i].charCodeAt(0); // char->int (checks for ip overrun)
				}
				if(i<this.code.length) a = this.code[i].charCodeAt(0);
				else a=0;
				var out = ((imm1&65535)<<16)|(imm2&65535);
				if(this.isImmop(a))
				{
					switch(a)
					{
						case 115:
							this.parsedCode[j] = new Array(2,this.alu.sin(out)); 
							break;
						case 113:
							this.parsedCode[j] = new Array(2,this.alu.sqrt(out)); 
							break;
						case 126:
							this.parsedCode[j] = new Array(2,this.alu.not(out)); 
							break;
						default:
							this.parsedCode[j] = new Array(3,out,a);
							break;
					}
					i++;
				}
				else this.parsedCode[j] = new Array(2,out);
				j++;
			}
			else if(this.isOpcode(a))
			{
				this.parsedCode[j] = new Array(1,a);
				i++;
				j++;
			}
			else i++;
		}
	}
	this.configureStackmode = function()
	{
		// reset the machine
		this.mode = 0;
		this.stackmode = 0;
		this.terminate = 0;
		this.stack.clear();
		this.ip = 0;
		// push media context
		this.pushmedia();
		// loop
		while(this.terminate!=1)
		{
			this.execOne();
			this.ip++;
		}
		if(this.stack.pos>0) this.stackmode = 1;
	}
	this.getOp = function(ip)
	{
		var cmd = this.parsedCode[this.ip];
		if(cmd[0]==1) return cmd[1];
	}
	this.execOne = function()
	{
		if(this.terminate==1) return;
		if(this.ip>=this.parsedCode.length)
		{
			this.terminate=1;
			return;
		}
		var cmd = this.parsedCode[this.ip];
		switch(cmd[0])
		{
			case 3: // imm+op
				switch(cmd[2])
				{
					case 43:
						this.stack.push(this.alu.add(cmd[1],this.stack.pop())); 
						break;
					case 45:
						this.stack.push(this.alu.sub(cmd[1],this.stack.pop())); 
						break;
					case 42:
						this.stack.push(this.alu.mul(cmd[1],this.stack.pop())); 
						break;
					case 47:
						this.stack.push(this.alu.div(cmd[1],this.stack.pop())); 
						break;
					case 37:
						this.stack.push(this.alu.mod(cmd[1],this.stack.pop())); 
						break;
					case 38:
						this.stack.push(this.alu.and(cmd[1],this.stack.pop())); 
						break;
					case 124:
						this.stack.push(this.alu.or(cmd[1],this.stack.pop())); 
						break;
					case 94:
						this.stack.push(this.alu.xor(cmd[1],this.stack.pop())); 
						break;
					case 108:
						this.stack.push(this.alu.shl(cmd[1],this.stack.pop())); 
						break;
					case 114:
						this.stack.push(this.alu.ror(cmd[1],this.stack.pop())); 
						break;
					case 97:
						this.stack.push(this.alu.atan2(cmd[1],this.stack.pop())); 
						break;
					case 115:
						this.stack.push(this.alu.sin(cmd[1])); 
						break;
					case 113:
						this.stack.push(this.alu.sqrt(cmd[1])); 
						break;
					case 126:
						this.stack.push(this.alu.not(cmd[1])); 
						break;
					case 100:
						this.stack.push2(cmd[1]);
						break;
					case 112:
						break;
				}
				break;
			case 2: // imm
				this.stack.push(cmd[1]);
				break;
			case 1: // op
				var chr = cmd[1];
				var a;
				if(this.isLimm(chr))
				{
					// Loadimm!
					var imm1 = 0; // number
					var imm2 = 0; // fraction
					var mode = 0; // number/fraction time?
					a = chr; // char->int
					while(this.isLimm(a) && this.terminate==0)
					{
						if(a==46) mode=1; // dot, time to switch modes!
						else {
							if(mode==0)
							{
								if(a>=48 && a<=57) imm1=(imm1<<4)|(a-48); // number, 0-9
								else imm1=(imm1<<4)|(a-55); // fraction, A-F
							}
							else
							{
								if(a>=48 && a<=57) imm2=(imm2>>4)|((a-48)<<12); // fraction, 0-9
								else imm2=(imm2>>4)|((a-55)<<12); // fraction, A-F
							}
						}
						this.ip++; // increment IP
						if(this.ip<this.parsedCode.length) a = this.getOp(this.ip); // char->int (checks for ip overrun)
						else { a=0; this.terminate=1; } // ip overrun, derpit
					}
					this.stack.push(((imm1&65535)<<16)|(imm2&65535)); // combine and push
					this.ip--; // decrement IP to be incremented by this.run
				}
				else switch(chr)
				{
					// Math!
					case 43:
						a = this.stack.pop();
						this.stack.push(this.alu.add(a,this.stack.pop())); 
						break;
					case 45:
						a = this.stack.pop();
						this.stack.push(this.alu.sub(a,this.stack.pop())); 
						break;
					case 42:
						a = this.stack.pop();
						this.stack.push(this.alu.mul(a,this.stack.pop())); 
						break;
					case 47:
						a = this.stack.pop();
						this.stack.push(this.alu.div(a,this.stack.pop())); 
						break;
					case 37:
						a = this.stack.pop();
						this.stack.push(this.alu.mod(a,this.stack.pop())); 
						break;
					case 38:
						a = this.stack.pop();
						this.stack.push(this.alu.and(a,this.stack.pop())); 
						break;
					case 124:
						a = this.stack.pop();
						this.stack.push(this.alu.or(a,this.stack.pop())); 
						break;
					case 94:
						a = this.stack.pop();
						this.stack.push(this.alu.xor(a,this.stack.pop())); 
						break;
					case 108:
						a = this.stack.pop();
						this.stack.push(this.alu.shl(a,this.stack.pop())); 
						break;
					case 114:
						a = this.stack.pop();
						this.stack.push(this.alu.ror(a,this.stack.pop())); 
						break;
					case 97:
						a = this.stack.pop();
						this.stack.push(this.alu.atan2(a,this.stack.pop())); 
						break;
					case 115:
						this.stack.push(this.alu.sin(this.stack.pop())); 
						break;
					case 113:
						this.stack.push(this.alu.sqrt(this.stack.pop())); 
						break;
					case 60:
						this.stack.push(this.alu.isneg(this.stack.pop())); 
						break;
					case 62:
						this.stack.push(this.alu.ispos(this.stack.pop())); 
						break;
					case 61:
						this.stack.push(this.alu.iszero(this.stack.pop())); 
						break;
					case 126:
						this.stack.push(this.alu.not(this.stack.pop())); 
						break;
					// Exterior!
					case 77: // media context switch
						this.mode=1;
						this.videoout = this.stack.pop();
						this.stack.clear();
					case 119: // where am I? well, where are you
						this.pushmedia();
						break;
					case 84:
						this.terminate = 1;
						break;
					// Stack!
					case 100:
						this.stack.dup();
						break;
					case 120:
						this.stack.exchange();
						break;
					case 118:
						this.stack.trirot();
						break;
					case 112:
						this.stack.pop();
						break;
					case 41:
						this.stack.push(this.stack.gettop(0-this.rol16(this.stack.pop())));
						break;
					case 40:
						a = this.rol16(this.stack.pop());
						this.stack.puttop(0-a,this.stack.pop());
						break;
					// Memory!
					case 64:
						this.stack.push(this.mem.get(this.rol16(this.stack.pop())));
						break;
					case 33:
						a = this.rol16(this.stack.pop());
						this.mem.put(a,this.stack.pop());
						break;
					case 63:
						a = this.stack.pop();
						if(a==0)
						{
							while(chr!=58 && this.terminate==0)
							{
								if(this.ip>=this.parsedCode.length) this.terminate=1;
								else this.ip++;
								chr = this.getOp(this.ip);
							}
						}
						break;
					case 58:
						while(chr!=59 && this.terminate==0)
						{
							if(this.ip>=this.parsedCode.length) this.terminate=1;
							else this.ip++;
							chr = this.getOp(this.ip);
						}
						break;
					// Return stack manipulation	
					case 82:
						this.stack.push(this.rstack.pop());
						break;
					case 80:
						this.rstack.push(this.stack.pop());
						break;
					// Loops
					case 105:
						this.stack.push(this.rstack.gettop(-1));
						break;
					case 106:
						this.stack.push(this.rstack.gettop(-3));
						break;
					case 74:
						this.ip = this.rol16(this.stack.pop())-1;
						break;
					case 91:
						this.rstack.push(this.rol16(this.ip+1));
						break;
					case 93:
						if(this.stack.pop()!=0) this.ip=this.rol16(this.rstack.gettop(0))-1;
						else this.rstack.pop();
						break;
					case 88:
						this.rstack.push(this.stack.pop());
						this.rstack.push(this.rol16(this.ip+1));
						break;
					case 76:
						a=this.rstack.gettop(-1)-(1<<16);
						this.rstack.puttop(-1,a);
						if(a!=0) this.ip=this.rol16(this.rstack.gettop(0))-1;
						else { this.rstack.pop(); this.rstack.pop(); }
						break;
					// Subroutines
					case 123:
						this.mem.put(this.rol16(this.stack.pop()),this.rol16(this.ip+1));
						while(chr!=125 && this.terminate==0)
						{
							if(this.ip>=this.parsedCode.length) this.terminate=1;
							else this.ip++;
							chr = this.getOp(this.ip);
						}
						break;
					case 125:
						this.ip = this.rol16(this.rstack.pop())-1;
						break;
					case 86:
						this.rstack.push(this.rol16(this.ip+1));
						this.ip = this.rol16(this.mem.get(this.rol16(this.stack.pop())))-1;
						break;
					default:
						break;
				}
				break;
			default:
				break;
		}
	}
}
var p = new Parser();
var oldloop = new Date;
var c = document.getElementById("ibniz").getContext("2d");
var runningCode = " ";
p.load(runningCode);
p.t=0;
var codeEdit = document.getElementById("code");
var fpsField = document.getElementById("fps");
var pause = document.getElementById("pause");
function clamp(a)
{
	if(a<0) return 0;
	else if(a>255) return 255;
	else return a;
}
function derp()
{
	if(!pause.checked)
	{
		var idd = c.createImageData(256,256);
		var id = idd.data;
		var imgpos = 0;
		var cy = 0;
		var cu = 0;
		var cv = 0;
		for(y=0;y<256;y++)
		{
			p.y=y;
			for(x=0;x<256;x++)
			{
				p.x=x;
				p.run();
				cy = ((p.videoout>>>8)&255);
				cu = (((p.videoout>>>16)&255)^0x80)-128;
				cv = (((p.videoout>>>24)&255)^0x80)-128;
				id[imgpos++] = clamp((298*cy + 409*cv + 128)>>8);
				id[imgpos++] = clamp((298*cy - 100*cu - 208*cv + 128)>>8);
				id[imgpos++] = clamp((298*cy + 516*cu + 128)>>8);
				id[imgpos++] = 255;
			}
		}
		p.configureStackmode();
		var newloop = new Date;
		var fps = 1000 / (newloop - oldloop);
		oldloop=newloop;
		p.t+=Math.round(30/fps);
		c.putImageData(idd,0,0);
		fpsField.childNodes[1].nodeValue=fps.toFixed(2);
		if(runningCode!=codeEdit.value)
		{
			p.t=0;
			runningCode=codeEdit.value;
			p.load(runningCode);
			console.log("NEW CODE LOADED");
		}
	}
	setTimeout("derp()",10); // give the browser time to not lag the whole computer
}
function loadFileURL()
{
	var url = prompt("Please input an URL","");
	var http = createRequestObject();
	function createRequestObject() { // http://www.openhosting.co.uk/articles/webdev/5899/
		var objAjax;
		var browser = navigator.appName;
		if(browser == "Microsoft Internet Explorer"){
			objAjax = new ActiveXObject("Microsoft.XMLHTTP");
		}else{
			objAjax = new XMLHttpRequest();
		}
		return objAjax;
	}
	function updateFileURL() {
		if(http.readyState == 4)
			codeEdit.value=http.responseText;
	}
	http.open('get',url);
	http.onreadystatechange = updateFileURL;
	http.send(null);
}
derp();
</script>
</body>
</html>
